var searchIndex = JSON.parse('{\
"erasable":{"doc":"Erase pointers of their concrete type and store…","i":[[3,"Thin","erasable","Wrapper struct to create thin pointer types.",null,null],[5,"erase","","Erase a pointer.",null,[[["nonnull",3],["sized",8]],["erasedptr",6]]],[6,"ErasedPtr","","A thin, type-erased pointer.",null,null],[8,"ErasablePtr","","A (smart) pointer type that can be type-erased (making a…",null,null],[10,"erase","","Turn this erasable pointer into an erased pointer.",0,[[],["erasedptr",6]]],[10,"unerase","","Unerase this erased pointer.",0,[[["erasedptr",6]]]],[8,"Erasable","","A pointee type that supports type-erased pointers (thin…",null,null],[11,"erase","","Turn this erasable pointer into an erased pointer.",1,[[["nonnull",3]],["erasedptr",6]]],[10,"unerase","","Unerase this erased pointer.",1,[[["erasedptr",6]],["nonnull",3]]],[18,"ACK_1_1_0","","Whether this implementor has acknowledged the 1.1.0 update…",1,null],[11,"into_inner","","Extract the wrapped pointer.",2,[[]]],[11,"with","","Run a closure with a borrow of the real pointer.",2,[[]]],[11,"with_mut","","Run a closure with a mutable borrow of the real pointer.",2,[[]]],[11,"ptr_eq","","Check two thin pointers for pointer equivalence.",2,[[["thin",3]]]],[11,"unerase","","",2,[[["nonnull",3],["erased",3]],["nonnull",3]]],[11,"from","","",2,[[]]],[11,"from","","",2,[[]]],[11,"into_iter","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"into_future","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"to_string","","",2,[[],["string",3]]],[11,"erase","","",2,[[],["erasedptr",6]]],[11,"unerase","","",2,[[["erasedptr",6]]]],[11,"deref","","",2,[[]]],[11,"deref_mut","","",2,[[]]],[11,"from","","",2,[[]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"eq","","",2,[[["thin",3]]]],[11,"cmp","","",2,[[["thin",3]],["ordering",4]]],[11,"partial_cmp","","",2,[[["thin",3]],[["ordering",4],["option",4]]]],[11,"drop","","",2,[[]]],[11,"hash","","",2,[[]]],[11,"finish","","",2,[[]]],[11,"write","","",2,[[]]],[11,"write_u8","","",2,[[]]],[11,"write_u16","","",2,[[]]],[11,"write_u32","","",2,[[]]],[11,"write_u64","","",2,[[]]],[11,"write_u128","","",2,[[]]],[11,"write_usize","","",2,[[]]],[11,"write_i8","","",2,[[]]],[11,"write_i16","","",2,[[]]],[11,"write_i32","","",2,[[]]],[11,"write_i64","","",2,[[]]],[11,"write_i128","","",2,[[]]],[11,"write_isize","","",2,[[]]],[11,"next","","",2,[[],["option",4]]],[11,"size_hint","","",2,[[]]],[11,"nth","","",2,[[],["option",4]]],[11,"next_back","","",2,[[],["option",4]]],[11,"nth_back","","",2,[[],["option",4]]],[11,"from_iter","","",2,[[["intoiterator",8]]]],[11,"as_ref","","",2,[[]]],[11,"as_mut","","",2,[[]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"clone","","",2,[[]]],[11,"poll","","",2,[[["context",3],["pin",3]],["poll",4]]]],"p":[[8,"ErasablePtr"],[8,"Erasable"],[3,"Thin"]]},\
"ptr_union":{"doc":"Pointer union types the size of a pointer by storing the…","i":[[3,"Union2","ptr_union","A pointer union of two pointer types.",null,null],[3,"Union4","","A pointer union of four pointer types.",null,null],[3,"Builder2","","A builder for [`Union2`].",null,null],[3,"Builder4","","A builder for [`Union4`].",null,null],[4,"Enum2","","An unpacked version of [`Union2`].",null,null],[13,"A","","",0,null],[13,"B","","",0,null],[4,"Enum4","","An unpacked version of [`Union4`].",null,null],[13,"A","","",1,null],[13,"B","","",1,null],[13,"C","","",1,null],[13,"D","","",1,null],[11,"new_unchecked","","Assert that creating pointer unions of these types is safe.",2,[[]]],[11,"is_a","","Check if the union is this variant.",3,[[]]],[11,"into_a","","Extract this variant from the union.",3,[[],["result",4]]],[11,"with_a","","Run a closure with this variant.",3,[[],["option",4]]],[11,"a","","Get a reference to this variant\'s target.",3,[[],["option",4]]],[11,"clone_a","","Clone this variant out of the union.",3,[[],["option",4]]],[11,"copy_a","","Copy this variant out of the union.",3,[[],["option",4]]],[11,"is_b","","Check if the union is this variant.",3,[[]]],[11,"into_b","","Extract this variant from the union.",3,[[],["result",4]]],[11,"with_b","","Run a closure with this variant.",3,[[],["option",4]]],[11,"b","","Get a reference to this variant\'s target.",3,[[],["option",4]]],[11,"clone_b","","Clone this variant out of the union.",3,[[],["option",4]]],[11,"copy_b","","Copy this variant out of the union.",3,[[],["option",4]]],[11,"ptr_eq","","Check if two unions are the same variant and point to the…",3,[[]]],[11,"as_deref","","Dereference the current pointer.",3,[[["builder2",3]],["union2",3]]],[11,"as_deref_unchecked","","Dereference the current pointer.",3,[[],["union2",3]]],[11,"unpack","","Unpack this union into an enum.",3,[[],["enum2",4]]],[11,"as_untagged_ptr","","Get the raw type-erased untagged pointer to the payload.",3,[[],["erasedptr",6]]],[11,"pack","","Pack this loose enum into a pointer union.",0,[[["builder2",3]],["union2",3]]],[11,"pack_unchecked","","Pack this loose enum into a pointer union.",0,[[],["union2",3]]],[11,"new_unchecked","","Assert that creating pointer unions of these types is safe.",4,[[]]],[11,"is_a","","Check if the union is this variant.",5,[[]]],[11,"into_a","","Extract this variant from the union.",5,[[],["result",4]]],[11,"with_a","","Run a closure with this variant.",5,[[],["option",4]]],[11,"a","","Get a reference to this variant\'s target.",5,[[],["option",4]]],[11,"clone_a","","Clone this variant out of the union.",5,[[],["option",4]]],[11,"copy_a","","Copy this variant out of the union.",5,[[],["option",4]]],[11,"is_b","","Check if the union is this variant.",5,[[]]],[11,"into_b","","Extract this variant from the union.",5,[[],["result",4]]],[11,"with_b","","Run a closure with this variant.",5,[[],["option",4]]],[11,"b","","Get a reference to this variant\'s target.",5,[[],["option",4]]],[11,"clone_b","","Clone this variant out of the union.",5,[[],["option",4]]],[11,"copy_b","","Copy this variant out of the union.",5,[[],["option",4]]],[11,"is_c","","Check if the union is this variant.",5,[[]]],[11,"into_c","","Extract this variant from the union.",5,[[],["result",4]]],[11,"with_c","","Run a closure with this variant.",5,[[],["option",4]]],[11,"c","","Get a reference to this variant\'s target.",5,[[],["option",4]]],[11,"clone_c","","Clone this variant out of the union.",5,[[],["option",4]]],[11,"copy_c","","Copy this variant out of the union.",5,[[],["option",4]]],[11,"is_d","","Check if the union is this variant.",5,[[]]],[11,"into_d","","Extract this variant from the union.",5,[[],["result",4]]],[11,"with_d","","Run a closure with this variant.",5,[[],["option",4]]],[11,"d","","Get a reference to this variant\'s target.",5,[[],["option",4]]],[11,"clone_d","","Clone this variant out of the union.",5,[[],["option",4]]],[11,"copy_d","","Copy this variant out of the union.",5,[[],["option",4]]],[11,"ptr_eq","","Check if two unions are the same variant and point to the…",5,[[]]],[11,"as_deref","","Dereference the current pointer.",5,[[["builder4",3]],["union4",3]]],[11,"as_deref_unchecked","","Dereference the current pointer.",5,[[],["union4",3]]],[11,"unpack","","Unpack this union into an enum.",5,[[],["enum4",4]]],[11,"as_untagged_ptr","","Get the raw type-erased untagged pointer to the payload.",5,[[],["erasedptr",6]]],[11,"pack","","Pack this loose enum into a pointer union.",1,[[["builder4",3]],["union4",3]]],[11,"pack_unchecked","","Pack this loose enum into a pointer union.",1,[[],["union4",3]]],[11,"a","","Construct a union at this variant.",2,[[],["union2",3]]],[11,"b","","Construct a union at this variant.",2,[[],["union2",3]]],[11,"a","","Construct a union at this variant.",4,[[],["union4",3]]],[11,"b","","Construct a union at this variant.",4,[[],["union4",3]]],[11,"c","","Construct a union at this variant.",4,[[],["union4",3]]],[11,"d","","Construct a union at this variant.",4,[[],["union4",3]]],[11,"from","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"into","","",3,[[]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"unerase","","",3,[[["nonnull",3],["erased",3]],["nonnull",3]]],[11,"to_owned","","",3,[[]]],[11,"clone_into","","",3,[[]]],[11,"from","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"into","","",5,[[]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"unerase","","",5,[[["nonnull",3],["erased",3]],["nonnull",3]]],[11,"to_owned","","",5,[[]]],[11,"clone_into","","",5,[[]]],[11,"from","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"unerase","","",2,[[["nonnull",3],["erased",3]],["nonnull",3]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"from","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"into","","",4,[[]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"unerase","","",4,[[["nonnull",3],["erased",3]],["nonnull",3]]],[11,"to_owned","","",4,[[]]],[11,"clone_into","","",4,[[]]],[11,"from","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"unerase","","",0,[[["nonnull",3],["erased",3]],["nonnull",3]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"from","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"unerase","","",1,[[["nonnull",3],["erased",3]],["nonnull",3]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",5,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",4,[[["formatter",3]],["result",6]]],[11,"eq","","",0,[[["enum2",4]]]],[11,"ne","","",0,[[["enum2",4]]]],[11,"eq","","",1,[[["enum4",4]]]],[11,"ne","","",1,[[["enum4",4]]]],[11,"eq","","",3,[[]]],[11,"eq","","",5,[[]]],[11,"drop","","",3,[[]]],[11,"drop","","",5,[[]]],[11,"hash","","",0,[[]]],[11,"hash","","",1,[[]]],[11,"hash","","",3,[[]]],[11,"hash","","",5,[[]]],[11,"clone","","",0,[[],["enum2",4]]],[11,"clone","","",1,[[],["enum4",4]]],[11,"clone","","",3,[[]]],[11,"clone","","",5,[[]]],[11,"clone","","",2,[[]]],[11,"clone","","",4,[[]]],[11,"erase","","",3,[[],["erasedptr",6]]],[11,"unerase","","",3,[[["erasedptr",6]]]],[11,"erase","","",5,[[],["erasedptr",6]]],[11,"unerase","","",5,[[["erasedptr",6]]]]],"p":[[4,"Enum2"],[4,"Enum4"],[3,"Builder2"],[3,"Union2"],[3,"Builder4"],[3,"Union4"]]},\
"rc_borrow":{"doc":"Borrowed forms of [`Rc`] and [`Arc`].","i":[[3,"ArcBorrow","rc_borrow","Borrowed version of [`Arc`].",null,null],[3,"RcBorrow","","Borrowed version of [`Rc`].",null,null],[11,"upgrade","","Convert this borrowed pointer into an owned pointer.",0,[[],["arc",3]]],[11,"to_weak","","Convert this borrowed pointer into a weak pointer.",0,[[],["weak",3]]],[11,"downgrade","","Convert this borrowed pointer into a standard reference.",0,[[]]],[11,"strong_count","","Get the number of strong owning pointers to this allocation.",0,[[]]],[11,"weak_count","","Get the number of weak owning pointers to this allocation.",0,[[]]],[11,"into_raw","","Get a raw pointer that can be used with `from_raw`.",0,[[]]],[11,"from_raw","","Construct a new `ArcBorrow` from a raw pointer.",0,[[]]],[11,"upgrade","","Convert this borrowed pointer into an owned pointer.",1,[[],["rc",3]]],[11,"to_weak","","Convert this borrowed pointer into a weak pointer.",1,[[],["weak",3]]],[11,"downgrade","","Convert this borrowed pointer into a standard reference.",1,[[]]],[11,"strong_count","","Get the number of strong owning pointers to this allocation.",1,[[]]],[11,"weak_count","","Get the number of weak owning pointers to this allocation.",1,[[]]],[11,"into_raw","","Get a raw pointer that can be used with `from_raw`.",1,[[]]],[11,"from_raw","","Construct a new `RcBorrow` from a raw pointer.",1,[[]]],[11,"from","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"to_string","","",0,[[],["string",3]]],[11,"unerase","","",0,[[["nonnull",3],["erased",3]],["nonnull",3]]],[11,"from","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"to_string","","",1,[[],["string",3]]],[11,"unerase","","",1,[[["nonnull",3],["erased",3]],["nonnull",3]]],[11,"deref","","",0,[[]]],[11,"deref","","",1,[[]]],[11,"from","","",0,[[["arc",3]],["arcborrow",3]]],[11,"from","","",1,[[["rc",3]],["rcborrow",3]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"eq","","",0,[[]]],[11,"eq","","",1,[[]]],[11,"cmp","","",0,[[],["ordering",4]]],[11,"cmp","","",1,[[],["ordering",4]]],[11,"partial_cmp","","",0,[[],[["ordering",4],["option",4]]]],[11,"partial_cmp","","",1,[[],[["ordering",4],["option",4]]]],[11,"hash","","",0,[[]]],[11,"hash","","",1,[[]]],[11,"as_ref","","",0,[[]]],[11,"as_ref","","",1,[[]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"clone","","",0,[[]]],[11,"clone","","",1,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow","","",1,[[]]],[11,"to_socket_addrs","","",0,[[],["result",6]]],[11,"to_socket_addrs","","",1,[[],["result",6]]],[11,"erase","","",0,[[],["erasedptr",6]]],[11,"unerase","","",0,[[["erasedptr",6]]]],[11,"erase","","",1,[[],["erasedptr",6]]],[11,"unerase","","",1,[[["erasedptr",6]]]]],"p":[[3,"ArcBorrow"],[3,"RcBorrow"]]},\
"rc_box":{"doc":"Known unique versions of [`Rc`] and [`Arc`]. This allows…","i":[[3,"ArcBox","rc_box","Known unique version of [`Arc`].",null,null],[3,"RcBox","","Known unique version of [`Rc`].",null,null],[11,"downcast","","Attempt to downcast the box to a concrete type.",0,[[],[["result",4],["arcbox",3]]]],[11,"downcast","","Attempt to downcast the box to a concrete type.",0,[[],[["result",4],["arcbox",3]]]],[11,"downcast","","Attempt to downcast the box to a concrete type.",0,[[],[["result",4],["arcbox",3]]]],[11,"from_raw","","Construct an ArcBox from a raw pointer.",0,[[]]],[11,"get_mut","","Get a mutable reference into the `ArcBox`.",0,[[],["option",4]]],[11,"get_mut_unchecked","","Get a mutable reference into the `ArcBox`.",0,[[]]],[11,"as_raw","","Returns a raw pointer to the object `T` pointed to by this…",0,[[],["nonnull",3]]],[11,"into_raw","","Consume the `ArcBox`, returning the wrapped pointer.",0,[[],["nonnull",3]]],[11,"leak","","Consume and leak the `ArcBox`.",0,[[]]],[11,"new","","Create a new ArcBox.",0,[[]]],[11,"pin","","Construct a new `Pin<ArcBox<T>>`. If `T` does not…",0,[[],[["pin",3],["arcbox",3]]]],[11,"into_inner","","Deconstruct this `ArcBox`, returning the inner value.",0,[[]]],[11,"downcast","","Attempt to downcast the box to a concrete type.",1,[[],[["result",4],["rcbox",3]]]],[11,"downcast","","Attempt to downcast the box to a concrete type.",1,[[],[["result",4],["rcbox",3]]]],[11,"downcast","","Attempt to downcast the box to a concrete type.",1,[[],[["result",4],["rcbox",3]]]],[11,"from_raw","","Construct an RcBox from a raw pointer.",1,[[]]],[11,"get_mut","","Get a mutable reference into the `RcBox`.",1,[[],["option",4]]],[11,"get_mut_unchecked","","Get a mutable reference into the `RcBox`.",1,[[]]],[11,"as_raw","","Returns a raw pointer to the object `T` pointed to by this…",1,[[],["nonnull",3]]],[11,"into_raw","","Consume the `RcBox`, returning the wrapped pointer.",1,[[],["nonnull",3]]],[11,"leak","","Consume and leak the `RcBox`.",1,[[]]],[11,"new","","Create a new RcBox.",1,[[]]],[11,"pin","","Construct a new `Pin<RcBox<T>>`. If `T` does not implement…",1,[[],[["rcbox",3],["pin",3]]]],[11,"into_inner","","Deconstruct this `RcBox`, returning the inner value.",1,[[]]],[11,"from","","",0,[[]]],[11,"from","","",0,[[]]],[11,"into_iter","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"to_string","","",0,[[],["string",3]]],[11,"unerase","","",0,[[["nonnull",3],["erased",3]],["nonnull",3]]],[11,"from","","",1,[[]]],[11,"from","","",1,[[]]],[11,"into_iter","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"to_string","","",1,[[],["string",3]]],[11,"unerase","","",1,[[["nonnull",3],["erased",3]],["nonnull",3]]],[11,"deref","","",0,[[]]],[11,"deref","","",1,[[]]],[11,"deref_mut","","",0,[[]]],[11,"deref_mut","","",1,[[]]],[11,"from","","",0,[[]]],[11,"from","","",0,[[]]],[11,"from","","",0,[[["box",3]]]],[11,"from","","",0,[[["string",3]]]],[11,"from","","",0,[[]]],[11,"from","","",0,[[["vec",3]]]],[11,"from","","",1,[[]]],[11,"from","","",1,[[]]],[11,"from","","",1,[[["box",3]]]],[11,"from","","",1,[[["string",3]]]],[11,"from","","",1,[[]]],[11,"from","","",1,[[["vec",3]]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"eq","","",0,[[]]],[11,"eq","","",1,[[]]],[11,"cmp","","",0,[[],["ordering",4]]],[11,"cmp","","",1,[[],["ordering",4]]],[11,"partial_cmp","","",0,[[],[["ordering",4],["option",4]]]],[11,"partial_cmp","","",1,[[],[["ordering",4],["option",4]]]],[11,"drop","","",0,[[]]],[11,"drop","","",1,[[]]],[11,"hash","","",0,[[]]],[11,"hash","","",1,[[]]],[11,"finish","","",0,[[]]],[11,"write","","",0,[[]]],[11,"write_u8","","",0,[[]]],[11,"write_u16","","",0,[[]]],[11,"write_u32","","",0,[[]]],[11,"write_u64","","",0,[[]]],[11,"write_u128","","",0,[[]]],[11,"write_usize","","",0,[[]]],[11,"write_i8","","",0,[[]]],[11,"write_i16","","",0,[[]]],[11,"write_i32","","",0,[[]]],[11,"write_i64","","",0,[[]]],[11,"write_i128","","",0,[[]]],[11,"write_isize","","",0,[[]]],[11,"finish","","",1,[[]]],[11,"write","","",1,[[]]],[11,"write_u8","","",1,[[]]],[11,"write_u16","","",1,[[]]],[11,"write_u32","","",1,[[]]],[11,"write_u64","","",1,[[]]],[11,"write_u128","","",1,[[]]],[11,"write_usize","","",1,[[]]],[11,"write_i8","","",1,[[]]],[11,"write_i16","","",1,[[]]],[11,"write_i32","","",1,[[]]],[11,"write_i64","","",1,[[]]],[11,"write_i128","","",1,[[]]],[11,"write_isize","","",1,[[]]],[11,"next","","",0,[[],["option",4]]],[11,"size_hint","","",0,[[]]],[11,"nth","","",0,[[],["option",4]]],[11,"next","","",1,[[],["option",4]]],[11,"size_hint","","",1,[[]]],[11,"nth","","",1,[[],["option",4]]],[11,"next_back","","",0,[[],["option",4]]],[11,"nth_back","","",0,[[],["option",4]]],[11,"next_back","","",1,[[],["option",4]]],[11,"nth_back","","",1,[[],["option",4]]],[11,"from_iter","","",0,[[["intoiterator",8]]]],[11,"from_iter","","",1,[[["intoiterator",8]]]],[11,"try_from","","",0,[[["arc",3]],[["arcbox",3],["arc",3],["result",4]]]],[11,"try_from","","",1,[[["rc",3]],[["rcbox",3],["result",4],["rc",3]]]],[11,"as_ref","","",0,[[]]],[11,"as_ref","","",1,[[]]],[11,"as_mut","","",0,[[]]],[11,"as_mut","","",1,[[]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"borrow","","",0,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"erase","","",0,[[],["erasedptr",6]]],[11,"unerase","","",0,[[["erasedptr",6]]]],[11,"erase","","",1,[[],["erasedptr",6]]],[11,"unerase","","",1,[[["erasedptr",6]]]]],"p":[[3,"ArcBox"],[3,"RcBox"]]},\
"slice_dst":{"doc":"Support for custom slice-based DSTs.","i":[[3,"SliceWithHeader","slice_dst","A custom slice-based DST.",null,null],[12,"header","","The included header. Does not dictate the slice length.",0,null],[12,"slice","","The included slice.",0,null],[3,"StrWithHeader","","A custom str-based DST.",null,null],[12,"header","","The included header. Does not dictate the slice length.",1,null],[12,"str","","The included str.",1,null],[5,"alloc_slice_dst","","Allocate a slice-based DST with the [global…",null,[[],[["sized",8],["nonnull",3],["slicedst",8]]]],[5,"alloc_slice_dst_in","","Allocate a slice-based DST with the [global…",null,[[],[["sized",8],["nonnull",3],["slicedst",8]]]],[11,"new","","Create a new slice/header DST in a [`AllocSliceDst`]…",0,[[]]],[11,"new","","Create a new str/header DST in a [`AllocSliceDst`]…",1,[[]]],[8,"SliceDst","","A custom slice-based dynamically sized type.",null,null],[10,"layout_for","","Get the layout of the slice-containing type with the given…",2,[[],["layout",3]]],[10,"retype","","Add the type onto an untyped pointer.",2,[[["nonnull",3]],["nonnull",3]]],[8,"AllocSliceDst","","Types that can allocate a custom slice DST within them.",null,null],[10,"new_slice_dst","","Create a new custom slice DST.",3,[[]]],[8,"TryAllocSliceDst","","Types that can allocate a custom slice DST within them,…",null,null],[10,"try_new_slice_dst","","Create a new custom slice DST with a fallible…",4,[[],["result",4]]],[11,"from","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"unerase","","",0,[[["nonnull",3],["erased",3]],["nonnull",3]]],[11,"from","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"unerase","","",1,[[["nonnull",3],["erased",3]],["nonnull",3]]],[11,"layout_for","","",0,[[],["layout",3]]],[11,"retype","","",0,[[["nonnull",3]],["nonnull",3]]],[11,"layout_for","","",1,[[],["layout",3]]],[11,"retype","","",1,[[["nonnull",3]],["nonnull",3]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"eq","","",0,[[["slicewithheader",3]]]],[11,"ne","","",0,[[["slicewithheader",3]]]],[11,"eq","","",1,[[["strwithheader",3]]]],[11,"ne","","",1,[[["strwithheader",3]]]],[11,"hash","","",0,[[]]],[11,"hash","","",1,[[]]],[11,"unerase","","",0,[[["erasedptr",6]],["nonnull",3]]],[11,"unerase","","",1,[[["erasedptr",6]],["nonnull",3]]]],"p":[[3,"SliceWithHeader"],[3,"StrWithHeader"],[8,"SliceDst"],[8,"AllocSliceDst"],[8,"TryAllocSliceDst"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);